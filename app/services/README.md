# Services Layer (`app/services/`)

このディレクトリは、アプリケーションの **ビジネスロジック（ドメインロジック）** を担当するサービスレイヤーです。

Controller (`routers`) から呼び出され、以下の責務を担います：
1.  **オーケストレーション**: CRUD操作、AI生成、ファイル出力などの複数の処理を組み合わせて、一つの意味のある業務フロー（ユースケース）を実行します。
2.  **データ加工**: フォームからの生データをデータベースに適した形式に変換したり、逆にデータベースの値をUI表示用に整形したりします。
3.  **外部システム連携**: LLM API (Gemini/Ollama) や RAGパイプライン、Excel操作ライブラリとのインターフェースとして機能します。

## 🏗 アーキテクチャと設計思想

### 1. トランザクションスクリプト パターン
`plan_service.py` や `patient_service.py` は、特定のタスク（例: 「計画書を保存してExcelを出力する」）を実行するための手続き的な関数群として実装されています。
これにより、処理の流れが一目で分かりやすくなり、エラー発生時のロールバックやリカバリ手順も明確に記述されています。

### 2. シングルトンとキャッシュ (`rag_manager.py`)
AIモデルやRAGパイプラインの初期化はコスト（時間・メモリ）がかかります。
`rag_manager.py` では、初期化済みのインスタンスをグローバルな辞書で管理し、**スレッドセーフなロック機構** を介して再利用することで、レスポンス速度とリソース効率を最適化しています。

### 3. 戦略（Strategy）パターン (`llm/`)
AIバックエンド（Gemini vs Ollama）を切り替えてもビジネスロジックを変更しなくて済むよう、抽象基底クラス (`LLMClient`) を定義し、具体的な実装を隠蔽しています。

---

## 📁 主要モジュール詳細

### `plan_service.py` (計画書ワークフロー)
リハビリ計画書の保存・生成に関する一連の流れを制御します。
* **`execute_save_workflow`**: この関数が「保存ボタン」押下時の全てを統括します。
    1.  フォームデータの分離（基本情報、AI提案、履歴）。
    2.  `crud.plan` を呼び出してデータベースに保存。
    3.  `excel.writer` を呼び出してExcelファイルを生成。
    4.  一時的なデータのクリーンアップ。

### `patient_service.py` (患者データ加工)
患者情報の表示・編集に関するロジックです。
* **`normalize_form_data`**: HTMLフォーム特有の挙動（ラジオボタンの値を `func_basic_rolling_independent_chk=on` のような個別のチェックボックスキーに展開するなど）を吸収し、DB保存用のフラットな辞書に変換します。
* **`prepare_edit_page_data`**: 画面表示に必要な「患者基本情報」「過去の計画書履歴」「FIM/BIの推移グラフ用データ」をまとめて取得・整形し、Viewに渡すDTO (Data Transfer Object) のような辞書を作成します。

### `rag_manager.py` (RAGインフラ)
検索拡張生成 (RAG) システムのライフサイクル管理を行います。
* **動的ロード**: `rag_config.yaml` の設定を読み込み、指定されたパイプライン（実験設定）を動的に構築します。
* **スレッドセーフ**: サーバーへの同時アクセス時に競合が起きないよう、`threading.Lock` を使用して `RAGExecutor` の生成・取得を制御しています。

### `fact_db.py` (事実データベース)
* **役割**: RAGとは別に、医療用語や禁忌情報などを高速に検索するための軽量なSQLiteデータベースと検索ロジックを提供します。
* **MeCab連携**: 日本語の形態素解析を行い、表記揺れ（例: "THA" と "人工股関節全置換術"）を吸収して関連情報を検索します。

### サブパッケージ群

#### 📂 `llm/`
大規模言語モデルとの通信を担当。
* **`base.py`**: 全てのLLMクライアントが実装すべきインターフェース定義。
* **`gemini.py` / `ollama.py`**: 各AIプロバイダへのAPIリクエスト実装。ストリーミング生成 (`yield`) の制御もここで行います。
* **`rag_executor.py`**: `Rehab_RAG` ライブラリと連携し、検索・リランク・フィルタリング・生成の一連のパイプラインを実行します。

#### 📂 `excel/`
Excelファイルの読み書きを担当。
* **`writer.py`**: `openpyxl` を使用し、既存のテンプレートファイル (`template.xlsx`) のセル座標に対してデータを書き込みます。
* **`mappings.py`**: データベースのカラム名と、Excelのセル番地（例: "C5"）の対応表を管理しています。

#### 📂 `extraction/`
非構造化テキストからの情報抽出。
* **`fast_extractor.py`**: **GLiNER (Generalist Model for Named Entity Recognition)** などの軽量モデルや正規表現を使用し、自由記述のメモから「疾患名」「ADLスコア」「リスク」などを高速に抽出します。

## 🔗 依存関係

* **⬅️ Used by `app/routers/`**: コントローラーから呼び出されます。
* **➡️ Uses `app/crud/`**: データの永続化処理を委譲します。
* **➡️ Uses `app/models/`**: データ構造の参照に使用します。
* **➡️ Uses `Rehab_RAG/`**: 高度なRAG機能のために、別ディレクトリにあるライブラリを参照します。

## 📝 開発者向けメモ

* **Excelマッピングの修正**: Excelテンプレートのレイアウト（行・列の挿入など）を変更した場合は、コードを触らずに `excel/mappings.py` を更新するだけで対応できるように設計されています。
* **RAGパイプラインの切り替え**: 環境変数やコード変更ではなく、ルート直下の `rag_config.yaml` を書き換えるだけで、アプリケーション再起動時に新しいパイプラインが適用されます。